Sistemas Operativos y 
Distribuidos

Iren Lorenzo Fonseca
iren.fonseca@.ua.es

TEMA 1. Sistemas Operativos.

Sistema de Archivos, 
Concurrencia e IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Tema 1.3 Sistema de Archivos,
Concurrencia e IPC

Contenidos

Sistema de archivos
Estructura, Interfaz

Concurrencia
Definición, problemas y sincronización

IPC
Señales, tuberías, memoria compartida



Francisco Maciá Pérez

pmacia@dtic.ua.es

Introducción Sistema de Archivos
Interfaz con el Sistema de Archivos

Contenidos

Implementación del Sistema de 
Archivos



Francisco Maciá Pérez

pmacia@dtic.ua.es

Introducción
Definiciones básicas

• El ordenador para ejecutar programas necesita tenerlos en memoria 
principal

• Como la capacidad de memoria principal es reducida y además es volátil es 
necesario un Sistema de Almacenamiento Secundario (SAS) para contener 
los programas y datos que se vayan a utilizar

• El SO es el software encargado de la gestión del SAS

✓ Abstrae las propiedades físicas de los dispositivos de 
almacenamiento

✓ Proporciona una interfaz a los usuarios de acceso a la información
✓ Administra el espacio libre
✓ Realiza la asignación del almacenamiento



Francisco Maciá Pérez

pmacia@dtic.ua.es

Introducción
Definiciones básicas

El sistema de archivos está formado por:

• Colección de archivos. Cada uno de los cuales contiene datos relacionados.

• Estructura de directorios. Organiza todos los archivos del sistema y 
proporciona información sobre ellos.

• Particiones. Permite separar grandes colecciones de directorios.



Francisco Maciá Pérez

pmacia@dtic.ua.es

Interfaz con el 
Sistema de Archivos

Sistema de Archivos



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Archivos

Una abstracción para la manipulación de memoria secundaria ofrecida por el
sistema operativo

Una colección de información relacionada que reside en el almacenamiento
secundario a la cual se le asigna un nombre.

Una secuencia de bits, bytes, líneas o registros con un significado definido por 
el creador y el usuario.

Sistema de Archivos



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Archivos

Estructura lógica Estructura física
La estructura lógica se refiere a cómo los datos de La estructura física se refiere a cómo se almacenan los 

un archivo están organizados y presentados para los archivos en el dispositivo de almacenamiento, como un 
usuarios y las aplicaciones. disco duro o una unidad SSD. 

Desde esta perspectiva, se pueden distinguir Esta estructura está más relacionada con la 
diferentes formas de organización dependiendo del administración del almacenamiento por parte del 

tipo de archivo sistema operativo.



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Archivos

Secuencia de bytes. Por ejemplo, un archivo de texto es una secuencia 
de caracteres organizados en líneas.

Secuencia de registros. En algunos archivos, los datos están 1, Juan, 25 
organizados en registros, que pueden ser de tamaño fijo o variable 2, María, 30 
(ejemplo csv). 3, Pedro, 22

Estructura compleja. Están compuestos por diferentes tipos de datos organizados de manera 
estructurada y que requieren interpretaciones específicas para ser comprendidos por el sistema 
operativo o las aplicaciones. (ejemplo archivos ejecutables, archivos de formato gráfico)



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Archivos

Estructura lógica Estructura física
La estructura lógica se refiere a cómo los datos de La estructura física se refiere a cómo se almacenan los 

un archivo están organizados y presentados para los archivos en el dispositivo de almacenamiento, como un 
usuarios y las aplicaciones. disco duro o una unidad SSD. 

Desde esta perspectiva, se pueden distinguir Esta estructura está más relacionada con la 
diferentes formas de organización dependiendo del administración del almacenamiento por parte del 

tipo de archivo sistema operativo.



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Archivos

Secuencia de bloques:

• A nivel físico, los archivos se almacenan como una secuencia de bloques en 
el dispositivo de almacenamiento.

• Un bloque es la unidad mínima de almacenamiento que el sistema operativo 
maneja. 

• En los discos duros tradicionales, estos bloques corresponden a los sectores 
del disco.

• Los bloques tienen un tamaño fijo (por ejemplo, 4 KB) y un archivo puede 
ocupar uno o más bloques, dependiendo de su tamaño.



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Archivos

Conversión de bloques lógicos a bloques físicos:

• Los archivos son representados lógicamente como una secuencia de bytes o 
registros, pero físicamente están distribuidos en varios bloques dentro del 
disco.

• El sistema operativo se encarga de realizar la conversión entre los bloques 
lógicos (es decir, la visión secuencial de los datos por parte del usuario) y los 
bloques físicos (cómo se almacenan realmente los datos en el dispositivo).

• Esta conversión es transparente para el usuario, pero es fundamental para que 
el sistema operativo gestione correctamente el almacenamiento y acceso a los 
archivos.



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Archivos

Fragmentación Interna

• La fragmentación interna ocurre cuando los archivos no utilizan 
completamente el espacio asignado en los bloques. Dado que los bloques 
tienen un tamaño fijo, si un archivo no llena completamente un bloque, se 
desperdicia espacio.



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Archivos

Estructura lógica Estructura física
La estructura lógica se refiere a cómo los datos de La estructura física se refiere a cómo se almacenan los 

un archivo están organizados y presentados para los archivos en el dispositivo de almacenamiento, como un 
usuarios y las aplicaciones. disco duro o una unidad SSD. 

Desde esta perspectiva, se pueden distinguir Esta estructura está más relacionada con la 
diferentes formas de organización dependiendo del administración del almacenamiento por parte del 

tipo de archivo sistema operativo.



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Directorios

Directorio: Es una estructura que contiene una lista de archivos y 
otros directorios

Organización Jerárquica de Archivos: 
• La organización de archivos y directorios es jerárquica. 
• En sistemas operativos como Unix/Linux, esta jerarquía tiene 

un punto de partida llamado "directorio raíz" (/), desde el cual 
se organizan todos los archivos y directorios.

Sistema de Archivos



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Datos

Metadatos
Información adicional sobre el 

archivo, como su tamaño, fecha 
de modificación, permisos de 

acceso, entre otros. Extensiones
Son sufijos que indican el tipo de 
archivo, como .txt para un 
archivo de texto o .jpg para 

Nombres de archivos imágenes
Cada archivo y directorio tiene un 

nombre único dentro de su 
directorio. Algunos sistemas 

operativos permiten espacios y 
caracteres especiales en los 
nombres, pero otros tienen 

restricciones



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Estructura Interna

Aunque la base de los Sistemas de archivos son los directorios y los 
archivos, existen diferentes propuestas para estructurar los bloques 
que contienen la información y para almacenar y recuperar la 
información de gestión.

Sistemas de Archivos Comunes:

01 FAT32
FAT32

Un sistema de archivos más antiguo utilizado en dispositivos portátiles, como 
memorias USB. Soporta archivos de hasta 4 GB

02 NTFS
NTFS

Sistema de archivos de Windows, con soporte para archivos grandes, permisos 
avanzados y funciones como la compresión de archivos

03 Ext4
ext4

Común en distribuciones Linux, permite volúmenes de hasta 1 exabyte y archivos 
de hasta 16 TB. También tiene características de journaling, que previenen la 
corrupción de datos en caso de fallos.

Sistema de Archivos



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Estructura Interna

02
NTFS

• NTFS organiza los datos en una estructura jerárquica de archivos y 
carpetas, utilizando una estructura llamada Master File Table (MFT).

• Cada archivo tiene una entrada en el MFT, que contiene no solo 
metadatos sino también la ubicación física del archivo en el disco. En 
algunos casos, si un archivo es pequeño, los datos reales del archivo 
pueden almacenarse directamente en el MFT, lo que mejora el 
rendimiento.

• Si los datos son más grandes, el MFT contiene punteros que apuntan a 
los bloques donde los datos del archivo se almacenan físicamente en el 
disco.

Sistema de Archivos



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Estructura Interna

Aunque la base de los Sistemas de archivos son los directorios y los 
archivos, existen diferentes propuestas para estructurar los bloques 
que contienen la información y para almacenar y recuperar la 
información de gestión.

Sistemas de Archivos Comunes:

01 FAT32
FAT32

Un sistema de archivos más antiguo utilizado en dispositivos portátiles, como 
memorias USB. Soporta archivos de hasta 4 GB

02 NTFS
NTFS

Sistema de archivos de Windows, con soporte para archivos grandes, permisos 
avanzados y funciones como la compresión de archivos

03 Ext4
ext4

Común en distribuciones Linux, permite volúmenes de hasta 1 exabyte y archivos 
de hasta 16 TB. También tiene características de journaling, que previenen la 
corrupción de datos en caso de fallos.

Sistema de Archivos



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Estructura Interna

03
ext4

ext4 es un sistema de archivos moderno utilizado principalmente en 
distribuciones de Linux. Es la cuarta versión de la familia ext
(Extended Filesystem) y ofrece características avanzadas como soporte 
para archivos grandes, eficiencia en la gestión de espacio y mecanismos 
para prevenir la corrupción de datos.

Estructura de ext4:
• Bloques: ext4 organiza el disco en bloques
• Inodos: utiliza una estructura llamada inodo para almacenar 

información sobre los archivos. Cada archivo tiene un inodo que 
contiene:
• Propietario del archivo, permisos, tamaños y marcas de 

tiempo.
• Punteros a los bloques de disco donde están almacenados 

los datos.

Sistema de Archivos



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Estructura Interna

Aunque la base de los Sistemas de archivos son los directorios y los 
archivos, existen diferentes propuestas para estructurar los bloques 
que contienen la información y para almacenar y recuperar la 
información de gestión.

Sistemas de Archivos Comunes:

01 FAT32
FAT32

Un sistema de archivos más antiguo utilizado en dispositivos portátiles, como 
memorias USB. Soporta archivos de hasta 4 GB

02 NTFS
NTFS

Sistema de archivos de Windows, con soporte para archivos grandes, permisos 
avanzados y funciones como la compresión de archivos

03 Ext4
ext4

Común en distribuciones Linux, permite volúmenes de hasta 1 exabyte y archivos 
de hasta 16 TB. También tiene características de journaling, que previenen la 
corrupción de datos en caso de fallos.

Sistema de Archivos



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Operaciones

Operación Descripción Ejemplo en UNIX

El archivo se crea sin datos. Hay que 
Crear archivo encontrar espacio en el disco y anotar su fd = creat(filename, mode)

existencia.

Lee datos desde un archivo abierto, 
Leer archivo read(fd, buffer, nbytes)

copiándolos en un buffer.

Escribe datos desde un buffer hacia el 
Escribir en archivo write(fd, buffer, nbytes)

archivo.

Borrar archivo Elimina un archivo del sistema de archivos. unlink(filename)

Cambia el puntero del archivo a una nueva 
Rebobinado de archivo posición, útil para leer o escribir en lseek(fd, offset, where)

diferentes lugares.

Se utiliza para reducir el tamaño de un 
Truncar archivo fd = creat(filename, mode)

archivo, generalmente vaciándolo.

Obtiene la información del archivo, como 
Obtener atributos fd = fstat(filename, statbuf)

tamaño, permisos, etc.

¿Que se repite en todas las llamadas?

Sistema de Archivos



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Descriptores de Archivos (fd)

➢ Un descriptor de archivo es un número entero que el sistema 
operativo asigna a un archivo o recurso cuando se abre. Este número 
se usa en las llamadas al sistema como read(), write(), close(), etc., 
para referirse al archivo o recurso en cuestión.

➢ Por ejemplo, cuando se abre un archivo en un programa en C con 
open(), el SO devuelve un descriptor de archivo, que es un número 
único dentro del contexto del proceso. El programa usa este número 
para interactuar con el archivo.

Sistema de Archivos



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Tabla de descriptores de archivos 

➢ La tabla de descriptores de archivo es una estructura clave gestionada por el 
SO para facilitar la interacción entre los programas y los archivos o 
dispositivos de almacenamiento. 

➢ Cada vez que un programa abre un archivo, el SO asigna un descriptor de 
archivo (file descriptor), que actúa como un identificador que el programa usa 
para realizar operaciones de lectura, escritura o cierre sobre ese archivo.

Memoria de usuarios Memoria del kernel

TABLA DESCRIPTORES
ARCHIVO

PROCESO 1 TABLA DE ARCHIVOS ABIERTOS

PROCESO 2 Cada descriptor de archivo en el 
espacio del proceso apunta a 

una estructura de archivo en el PCB (PROCESS CONTROL BLOCK)
espacio de memoria del kernel. 

Esta estructura en el kernel TABLA DE 
contiene información como el PROCESOS

puntero de lectura/escritura, el 
modo de acceso y la referencia 

al inode del archivo.

Sistema de Archivos



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Ejemplos

Descriptores 0, 1, 2: Son los descriptores estándar (stdin, stdout, stderr), presentes por 
defecto en cada proceso. Apuntan a sus respectivas entradas en la tabla de archivos abiertos 
del kernel.

FD Archivo Referencia en la Tabla de Archivos Abiertos (kernel)

0 stdin (entrada estándar) Entrada 0 en la tabla del kernel

1 stdout (salida estándar) Entrada 1 en la tabla del kernel

2 stderr (error estándar) Entrada 2 en la tabla del kernel

3 /home/user/file.txt Entrada 3 en la tabla del kernel

Entrada 
Posición de Referencia Contador de 

en el Archivo Modo de Apertura
Lectura/Escritura al inode Referencias

kernel

0 (lectura en O_RDONLY (solo 
0 stdin Inode 1 1

espera) lectura)

O_WRONLY (solo 
1 stdout 0 (para escribir) Inode 2 1

escritura)

O_WRONLY (solo 
2 stderr 0 (para escribir) Inode 3 1

escritura)

/home/user/fil 120 (posición de O_RDWR (lectura y 
3 Inode 454 2

e.txt lectura) escritura)

TABLA DESCRIPTORES
ARCHIVO

Sistema de Archivos

TABLA DE ARCHIVOS ABIERTOS



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Operaciones

Operación Descripción Ejemplo en UNIX

El archivo se crea sin datos. Hay que 
Crear archivo encontrar espacio en el disco y anotar su fd = creat(filename, mode)

existencia.

Lee datos desde un archivo abierto, 
Leer archivo read(fd, buffer, nbytes)

copiándolos en un buffer.

Escribe datos desde un buffer hacia el 
Escribir en archivo write(fd, buffer, nbytes)

archivo.

Borrar archivo Elimina un archivo del sistema de archivos. unlink(filename)

Cambia el puntero del archivo a una nueva 
Rebobinado de archivo posición, útil para leer o escribir en lseek(fd, offset, where)

diferentes lugares.

Se utiliza para reducir el tamaño de un 
Truncar archivo fd = creat(filename, mode)

archivo, generalmente vaciándolo.

Obtiene la información del archivo, como 
Obtener atributos fd = fstat(filename, statbuf)

tamaño, permisos, etc.

¿Que se repite en todas las llamadas?

Sistema de Archivos



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Sesiones

Para utilizar un archivo hay que definir una sesión con las llamadas 
al sistema open (abrir) y close (cerrar).

1. El proceso llama a open(filename, mode) para 
void main(){

abrir el archivo "filename.txt" y el modo de 
apertura O_RDWR (lectura y escritura)

int fd = open("archivo.txt", O_RDWR); 
2. El kernel toma el control, localiza el archivo 

en el sistema de archivos y verifica permisos.
// uso del archivo

3. Si todo es correcto, el kernel:
…

1. Crea una entrada en la tabla de archivos 
abiertos del kernel.

close(fd)
2. Asigna un descriptor de archivo en la 

}
tabla de descriptores del proceso.

4. El descriptor de archivo se devuelve al 
proceso, que ahora puede usarlo para operar 
sobre el archivo (si falla open devuelve -1) 



Francisco Maciá Pérez

pmaIcnia@tdteic.ruaf.eas z con el Sistema de Archivos
Sesiones

Para utilizar un archivo hay que definir una sesión con las llamadas 
al sistema open (abrir) y close (cerrar).

1. El proceso llama a close(fd) para cerrar el 
void main(){

descriptor de archivo
2. El kernel verifica que fd sea un descriptor 

int fd = open("archivo.txt", O_RDWR); 
válido.

3. El kernel decrementa el contador de 
// uso del archivo

referencias del archivo asociado.
…

4. Si el contador llega a cero, el kernel libera los 
recursos asociados.

close(fd)
5. close() devuelve 0 en caso de éxito o -1 en 

}
caso de error.



Francisco Maciá Pérez

Ipmnacita@edticr.ufa.aesz con el Sistema de Archivos
Ejemplo



Francisco Maciá Pérez

pmacia@dtic.ua.es

Implementación del 
Sistema de Archivos

Sistema de Archivos



Francisco Maciá Pérez

pmaciIam@dtipc.luea.ems entación del Sistema de Archivos
Niveles de la memoria secundaria

Sistema de Archivos



Francisco Maciá Pérez

pmaciIam@dtipc.luea.ems entación del Sistema de Archivos
Métodos de asignación

Desde el punto de vista de la implementación un archivo 
es una colección de bloques. 
Existen varias técnicas que permiten implementar esa 
colección de bloques de modo que el espacio se aproveche 
de forma eficaz y se pueda acceder rápidamente a ellos.

Asignación contigua

Asignación enlazada

Asignación por tabla

Asignación indexada

Sistema de Archivos



Francisco Maciá Pérez

pmaciIam@dtipc.luea.ems entación del Sistema de Archivos
Métodos de asignación

Asignación contigua

• Cada archivo ocupa un conjunto de bloques consecutivos en el disco.
• Un archivo queda definido por el primer bloque y su tamaño en 

bloques

Sistema de Archivos



Francisco Maciá Pérez

pmaciIam@dtipc.luea.ems entación del Sistema de Archivos
Métodos de asignación

Asignación contigua

Ventaja: Rapidez de acceso ya que para acceder a 
bloques consecutivos no hace falta mover el 
cabezal del disco si fuese HDD.

Métodos de gestión: primer, mejor y siguiente 
hueco.

Primer Hueco: asigna el primer bloque de espacio libre que encuentra y 
que es lo suficientemente grande para satisfacer la solicitud de 
almacenamiento. Esto se hace escaneando la lista de bloques libres desde 
el principio hasta encontrar uno adecuado

Mejor Hueco: busca el bloque de espacio libre que se ajusta de manera 
más óptima a la solicitud, es decir, el bloque más pequeño que es capaz 
de satisfacer la demanda de espacio.

Siguiente Hueco: similar al de primer hueco, pero en lugar de comenzar 
la búsqueda desde el principio de la lista de bloques libres, empieza desde 
el último bloque asignado.

Sistema de Archivos



Francisco Maciá Pérez

pmaciIam@dtipc.luea.ems entación del Sistema de Archivos
Métodos de asignación

Asignación contigua

Ventaja: Rapidez de acceso ya que para acceder a 
bloques consecutivos no hace falta mover el 
cabezal del disco si fuese HDD.

Métodos de gestión: primer, mejor y siguiente 
hueco.

Desventajas: 
• El crecimiento de los archivos está limitado

• Posible solución: Reservar un número de bloques superior al 
requerido inicialmente (Producirá fragmentación interna y un 
escaso aprovechamiento del disco)

• Fragmentación externa
• Posible solución: Compactación

Sistema de Archivos



Francisco Maciá Pérez

pmaciIam@dtipc.luea.ems entación del Sistema de Archivos
Métodos de asignación

Desde el punto de vista de la implementación un archivo 
es una colección de bloques. 
Existen varias técnicas que permiten implementar esa 
colección de bloques de modo que el espacio se aproveche 
de forma eficaz y se pueda acceder rápidamente a ellos.

Asignación contigua

Asignación enlazada

Asignación por tabla

Asignación indexada

Sistema de Archivos



Francisco Maciá Pérez

pmaciIam@dtipc.luea.ems entación del Sistema de Archivos
Métodos de asignación

Asignación enlazada

• Cada archivo es una lista enlazada de bloques.
• La entrada de directorio da el número del primer bloque.
• Cada bloque tiene un puntero al siguiente.

Sistema de Archivos



Francisco Maciá Pérez

pmaciIam@dtipc.luea.ems entación del Sistema de Archivos
Métodos de asignación

Asignación enlazada

Ventajas:
• No limita el crecimiento de los archivos.
• Es fácil el aumento y reducción del tamaño de los archivos
• No existe fragmentación externa por lo que no existe necesidad 

de compactación.

Desventajas:
• Puede ser ineficiente en términos de espacio si los archivos son 

pequeños.

Sistema de Archivos



Francisco Maciá Pérez

pmaciIam@dtipc.luea.ems entación del Sistema de Archivos
Métodos de asignación

Desde el punto de vista de la implementación un archivo 
es una colección de bloques. 
Existen varias técnicas que permiten implementar esa 
colección de bloques de modo que el espacio se aproveche 
de forma eficaz y se pueda acceder rápidamente a ellos.

Asignación contigua

Asignación enlazada

Asignación por tabla

Asignación indexada

Sistema de Archivos



Francisco Maciá Pérez

pmaciIam@dtipc.luea.ems entación del Sistema de Archivos
Métodos de asignación

Asignación por tabla

Es una variante de la asignación enlazada en la que los punteros no se 
encuentran en el bloque, sino en una estructura de datos separada (File 
Allocation Table - FAT) localizada en los primeros bloques del disco.

Sistema de Archivos



Francisco Maciá Pérez

pmaciIam@dtipc.luea.ems entación del Sistema de Archivos
Métodos de asignación

Desde el punto de vista de la implementación un archivo 
es una colección de bloques. 
Existen varias técnicas que permiten implementar esa 
colección de bloques de modo que el espacio se aproveche 
de forma eficaz y se pueda acceder rápidamente a ellos.

Asignación contigua

Asignación enlazada

Asignación por tabla

Asignación indexada

Sistema de Archivos



Francisco Maciá Pérez

pmaciIam@dtipc.luea.ems entación del Sistema de Archivos
Métodos de asignación

Asignación indexada

• Cada archivo tiene un bloque de índice donde hay ubicado un 
vector con todos los punteros a los bloques del archivo.

• La i-ésima entrada del vector contiene el puntero al i-ésimo bloque.

Sistema de Archivos



Francisco Maciá Pérez

pmaciIam@dtipc.luea.ems entación del Sistema de Archivos
Métodos de asignación

Asignación indexada

Ventajas
• El acceso aleatorio (a un bloque concreto del 

archivo) se implementa eficientemente.
• No hay fragmentación externa.

Desventajas
• Con pocos bloques, el bloque de índice supone un desperdicio 

importante de espacio.
• El tamaño máximo del archivo está limitado por el número de 

punteros que cabe en un bloque.
• Fragmentación interna en los bloques índice.

Sistema de Archivos



Francisco Maciá Pérez

pmaciIam@dtipc.luea.ems entación del Sistema de Archivos
Gestión de espacios

Para llevar a cabo cualquiera de las técnicas de asignación anteriores, es 
necesario saber qué bloques del disco están disponibles. Para ello el SO 
debe mantener una estructura de datos con todos los bloques no asignados 
a archivos.

Mapa de Bits Lista enlazada de espacios libres

Sistema de Archivos



Francisco Maciá Pérez

pmacia@dtic.ua.es

Definición Concurrencia
Problemas de la concurrencia

Contenidos

Mecanismos de sincronización



Francisco Maciá Pérez

pmacia@dtic.ua.es

Introducción
Definiciones básicas

Proceso ≠ programa Proceso: Programa en ejecución

Servicios del SO

Ejecución concurrente

Sincronización de procesos 

Comunicación entre procesos



Francisco Maciá Pérez

pmacia@dtic.ua.es

Introducción
Definiciones básicas

Proceso ≠ programa Proceso: Programa en ejecución

Servicios del SO

Ejecución concurrente

Concurrencia
Sincronización de procesos Definición, problemas y sincronización

IPC
Comunicación entre procesos Señales, tuberías, memoria compartida



Francisco Maciá Pérez

pmacia@dtic.ua.es

Introducción
Definiciones básicas

Ejecución concurrente

Multiprogramación Multiprocesamiento Procesamiento Distribuido



Francisco Maciá Pérez

pmacia@dtic.ua.es

Definición
Concurrencia

La concurrencia es el concepto en SO y programación que se refiere a la 
capacidad de ejecutar múltiples tareas o procesos de manera que parezca 
que se están ejecutando al mismo tiempo. Estas tareas pueden ser 
programas, procesos o hilos que compiten por los recursos de un sistema.

Concurrencia



Francisco Maciá Pérez

pmacia@dtic.ua.es

Definición
Concurrencia

A diferencia del paralelismo, donde las tareas se ejecutan simultáneamente en 
diferentes procesadores o núcleos

En la concurrencia, las tareas pueden estar intercaladas en su ejecución en 
un solo procesador

Un SO gestiona la concurrencia al alternar entre los procesos o hilos de manera 
rápida para que parezca que se ejecutan a la vez

Aunque realmente se están ejecutando en pequeñas porciones de tiempo

Concurrencia



Francisco Maciá Pérez

pmacia@dtic.ua.es

Definición
Concurrencia

Que hay en un sistema multinúcleo o 
multiprocesador: ¿concurrencia o paralelismo?

Concurrencia



Francisco Maciá Pérez

pmacia@dtic.ua.es

Definición
Concurrencia y Paralelismo

En sistemas con múltiples procesadores o núcleos, puede 
haber concurrencia y paralelismo al mismo tiempo

Concurrencia Paralelismo
En concurrencia, el sistema operativo Paralelismo ocurre cuando varias 

puede estar alternando entre varias tareas se ejecutan simultáneamente 
tareas rápidamente, compartiendo los en diferentes núcleos o 

recursos de un solo procesador o de procesadores físicos. Es decir, 
múltiples núcleos varias tareas se ejecutan 

literalmente al mismo tiempo, cada 
una en su propio núcleo

• Un sistema puede tener varias tareas concurrentes, donde algunas se 
ejecutan en paralelo (cada una en un núcleo diferente), y otras se 
intercalan en el mismo núcleo.

• Por ejemplo, en un sistema de cuatro núcleos, el sistema operativo 
puede asignar varias tareas a diferentes núcleos (paralelismo), mientras 
que, dentro de cada núcleo, el sistema puede estar alternando entre 
varios hilos o procesos concurrentes (concurrencia)

Concurrencia



Francisco Maciá Pérez

pmacia@dtic.ua.es

Definición
Concurrencia y Paralelismo

Concurrencia sin paralelismo
En un sistema con un solo procesador, el SO intercalaría la ejecución de varios 
procesos, cambiando de uno a otro rápidamente. Ningún proceso se ejecuta al 
mismo tiempo que otro, pero todos parecen avanzar simultáneamente

Paralelismo sin concurrencia
En un sistema con varios procesadores, podrías asignar una tarea única y muy 
pesada a cada procesador, sin que tengan que intercalar la ejecución con otras 
tareas. Aquí los procesadores ejecutan tareas en paralelo, pero no hay alternancia 
de tareas

Concurrencia y paralelismo juntos
En un sistema con varios núcleos, puedes tener varios procesos concurrentes. 
Algunos de esos procesos pueden ejecutarse en paralelo (cada uno en un núcleo 
distinto), mientras que, dentro de cada núcleo, puede haber concurrencia, con 
varios hilos alternando en el mismo núcleo.

Concurrencia



Francisco Maciá Pérez

pmacia@dtic.ua.es

Definición
Concurrencia y Paralelismo

Concurrencia puede ocurrir tanto en sistemas de 
un solo procesador como en sistemas con 
múltiples procesadores.

Paralelismo solo es posible en sistemas con 
múltiples procesadores o núcleos

Concurrencia



Francisco Maciá Pérez

pmacia@dtic.ua.es

Problemas de la 
concurrencia

Concurrencia



Francisco Maciá Pérez

pmacia@Pdticr.uoa.ebs lemas de la concurrencia
problemas

Condiciones de Carrera 01

Sección crítica 02

Exclusión mutua 03

Concurrencia



Francisco Maciá Pérez

pmacia@Pdticr.uoa.ebs lemas de la concurrencia
Condición de Carrera

01
Condiciones de Carrera

La condición de carrera (race condition) es un problema que ocurre en 
sistemas concurrentes o paralelos cuando el resultado de la ejecución 
de un programa depende del orden de ejecución no controlado de 
varios hilos o procesos que acceden y modifican recursos compartidos

✓ En una condición de carrera, si varios procesos o hilos acceden 
simultáneamente a un recurso (como una variable compartida 
o una base de datos) sin una adecuada sincronización, el 
resultado final puede ser impredecible o incorrecto. 

✓ Esto sucede porque los hilos o procesos "compiten" por 
acceder a los recursos, y el orden en que lo hacen influye en el 
resultado.

Concurrencia



Francisco Maciá Pérez

pmaciPa@drtico.uab.eslemas de la concurrencia
Ejemplo

01
Condiciones de Carrera

El valor esperado de contador es 2000 (1000 incrementos 
por cada hilo)

Sin embargo, debido a la condición de carrera, el valor 
final podría ser incorrecto, como 1987, 1994, o cualquier 
otro número menor a 2000

Esto se debe a que ambos hilos están accediendo y 
modificando el valor de contador sin tener en cuenta 
el estado en el que se encuentra el otro hilo.



Francisco Maciá Pérez

pmaciPa@drtico.uab.eslemas de la concurrencia
Ejemplo

01
Condiciones de Carrera

El problema surge porque el proceso de lectura y escritura 
en contador no es atómico. Es decir, el incremento 
contador += 1 involucra múltiples pasos:

1. Leer el valor de contador.
2. Incrementar el valor.
3. Guardar el nuevo valor en contador.

Si dos hilos hacen esto al mismo tiempo, pueden leer 
el mismo valor antes de que cualquiera de ellos lo 
actualice, lo que genera resultados incorrectos.



Francisco Maciá Pérez

pmaciPa@drtico.uab.eslemas de la concurrencia
Ejemplo

01
Condiciones de Carrera

Solución: Sincronización

• Para evitar una condición de carrera, necesitamos 
sincronizar los hilos y asegurar que solo uno acceda
a la variable compartida a la vez. 

• Un mecanismo común es el uso de locks (mutex), que 
garantizan que solo un hilo pueda entrar en la sección 
crítica (el código que accede a la variable 
compartida) a la vez.



Francisco Maciá Pérez

pmacia@Pdticr.uoa.ebs lemas de la concurrencia
Condición de Carrera

01
Condiciones de Carrera

La condición de carrera (race condition) es un problema que ocurre en 
sistemas concurrentes o paralelos cuando el resultado de la ejecución 
de un programa depende del orden de ejecución no controlado de 
varios hilos o procesos que acceden y modifican recursos compartidos

✓ En una condición de carrera, si varios procesos o hilos acceden 
simultáneamente a un recurso (como una variable compartida 
o una base de datos) sin una adecuada sincronización, el 
resultado final puede ser impredecible o incorrecto. 

✓ Esto sucede porque los hilos o procesos "compiten" por 
acceder a los recursos, y el orden en que lo hacen influye en el 
resultado.

Concurrencia



Francisco Maciá Pérez

pmacia@Pdticr.uoa.ebs lemas de la concurrencia
problemas

Condiciones de Carrera 01

Sección crítica 02

Exclusión mutua 03

Concurrencia



Francisco Maciá Pérez

pmacia@Pdticr.uoa.ebs lemas de la concurrencia
Sección crítica

Sección crítica 02

Se denomina Sección Crítica (SC) de un proceso o hilo a aquellas 
partes del código que no pueden ejecutarse de forma concurrente. 

Problema:
Si dos procesos están dentro de la misma sección crítica al 
mismo tiempo, pueden modificar los recursos compartidos 
de manera no coordinada, causando problemas en los datos 
o el funcionamiento del sistema.

Concurrencia



Francisco Maciá Pérez

pmacia@Pdticr.uoa.ebs lemas de la concurrencia
Sección crítica

Sección crítica Es importante Las condiciones 02
de carrera son controlar
un problema de la SC
la concurrencia

Es importante Las condiciones 
controlar de carrera son 
la SC un problema de 

la concurrencia

Concurrencia



Francisco Maciá Pérez

pmacia@Pdticr.uoa.ebs lemas de la concurrencia
Sección crítica

Sección crítica 02
La gestión de concurrencia en este 
caso la implementa el SO (con colas de 
impresión) junto con los drivers

Es importante Las condiciones 
controlar de carrera son 
la SC un problema de 

la concurrencia

En el diseño de sistemas concurrentes es necesario que 
identifiquemos las secciones críticas para tratarlas 
correctamente y así evitar condiciones de carrera.

Concurrencia



Francisco Maciá Pérez

pmaciPa@drtico.uab.eslemas de la concurrencia
Ejemplo

Sección crítica 02

Identificar la sección crítica

SC

El objetivo es garantizar que, en cualquier momento, solo 
un proceso o hilo pueda ejecutar la sección crítica. Esto se 
logra mediante la exclusión mutua.



Francisco Maciá Pérez

pmacia@Pdticr.uoa.ebs lemas de la concurrencia
Sección crítica

Sección crítica 02
La gestión de concurrencia en este 
caso la implementa el SO (con colas de 
impresión) junto con los drivers

Es importante Las condiciones 
controlar de carrera son 
la SC un problema de 

la concurrencia

En el diseño de sistemas concurrentes es necesario que 
identifiquemos las secciones críticas para tratarlas 
correctamente y así evitar condiciones de carrera.

Concurrencia



Francisco Maciá Pérez

pmacia@Pdticr.uoa.ebs lemas de la concurrencia
problemas

Condiciones de Carrera 01

Sección crítica 02

Exclusión mutua 03

Concurrencia



Francisco Maciá Pérez

pmacia@Pdticr.uoa.ebs lemas de la concurrencia
Exclusión mutua

Exclusión mutua 03

La exclusión mutua asegura que una sección crítica sea ejecutada por 
un solo proceso o hilo a la vez. Esto evita la interferencia entre 
procesos.

La exclusión mutua es una propiedad que asegura que, cuando un 
proceso está ejecutando su sección crítica (SC) —es decir, la parte 
del código que accede a recursos compartidos—, ningún otro 
proceso puede acceder a esa SC hasta que el primer proceso haya 
terminado. 

El protocolo es un conjunto de reglas o mecanismos implementados 
en el código para asegurar que la SC se ejecute de forma exclusiva.

Concurrencia



Francisco Maciá Pérez

pmaciPa@dtrico.uab.eslemas de la concurrencia
Exclusión mutua

Exclusión mutua 03

Para que un mecanismo de exclusión mutua sea efectivo, debe cumplir con 
los siguientes requisitos

Acceso Exclusivo Interrupción Progreso

01 Solo un proceso debe 02 Cuando un proceso es 03 No puede demorarse un 
tener permiso para entrar interrumpido mientras proceso indefinidamente 
en la SC en un momento está en una región no en una sección crítica
dado. crítica, no debe interferir 

con el resto de los 
procesos. 

No Bloqueo Tiempo Finito

04 Cuando ningún proceso 05 Independencia 
de Velocidad 06 Un proceso debe 

está en su SC, cualquier permanecer en su SC solo 
proceso que solicite por un tiempo finito
entrar debe hacerlo sin No se deben hacer suposiciones 

dilación sobre la velocidad relativa de los 
procesos ni sobre el número de 
procesadores. Esto asegura que el 
mecanismo funcione en sistemas 
heterogéneos y con diferentes 
arquitecturas.



Francisco Maciá Pérez

pmaciPa@dtrico.uab.eslemas de la concurrencia
Exclusión mutua

Exclusión mutua 03

La responsabilidad de implementar y mantener la exclusión mutua recae 
sobre los procesos y sus programadores

• Es decir, los programadores deben utilizar mecanismos adecuados para 
asegurar que solo un proceso pueda acceder a la sección crítica en un 
momento dado.

• Los SO modernos implementan de manera nativa mecanismos de 
sincronización que permiten la implementación de la exclusión muta

…

P1 P2 P3 P4

Semáforos Mutex Monitores
…

Mecanismos de Sincronización …

KERNEL
SO APLICACIONES



Francisco Maciá Pérez

pmacia@dtic.ua.es

Mecanismos de 
Sincronización

Concurrencia



Francisco Maciá Pérez

pmaciaM@dtice.ua.cesanismos de Sincronización
Contenido

Semáforos 01

Mutex 02

Monitores 03

Concurrencia



Francisco Maciá Pérez

pmaciaM@dtice.ua.cesanismos de Sincronización
Semáforos

01 Semáforos

Un semáforo es una estructura de datos utilizada para controlar el 
acceso a recursos compartidos en un sistema operativo mediante 
operaciones atómicas.

60

Fue introducido por Edsger Dijkstra en los años 
60 para resolver problemas de sincronización y se 
implementan de forma experimental en sistemas 
académicos como el THE Operating System.

Concurrencia



Francisco Maciá Pérez

pmaciaM@dtice.ua.cesanismos de Sincronización
Semáforos

01 Semáforos

Un semáforo es una estructura de datos utilizada para controlar el 
acceso a recursos compartidos en un sistema operativo mediante 
operaciones atómicas.

70 - 80

Las primeras implementaciones comerciales en 
sistemas operativos como UNIX System V usan 
semáforos para IPC (comunicación entre procesos)

Concurrencia



Francisco Maciá Pérez

pmaciaM@dtice.ua.cesanismos de Sincronización
Semáforos

01 Semáforos

Un semáforo es una estructura de datos utilizada para controlar el 
acceso a recursos compartidos en un sistema operativo mediante 
operaciones atómicas.

90

Los semáforos se implementan de forma nativa y 
estandarizada en muchos sistemas operativos a 
través del estándar POSIX (POSIX.1b), haciendo 
que semáforos, mutexes y otros mecanismos de 
sincronización formen parte del kernel en sistemas 
como Linux, BSD, Windows NT, entre otros.

Concurrencia



Francisco Maciá Pérez

pmaciaM@dtice.ua.cesanismos de Sincronización
Tipos de semáforos

01 Semáforos

Un semáforo mantiene un contador que refleja el estado de disponibilidad de un 
recurso.

1. Semáforo Binario

o Solo permite que un único proceso acceda a la sección crítica a 
la vez.

2. Semáforo Contador:

o Permite un número limitado de procesos en la sección crítica.

o Se usa para gestionar acceso concurrente cuando múltiples 
instancias de un recurso están disponibles.

Concurrencia



Francisco Maciá Pérez

pmaciaM@dtice.ua.cesanismos de Sincronización
Operaciones en los semáforos

01 Semáforos

1. wait() (también conocida como P o down, acquire() en Python):

Concurrencia



Francisco Maciá Pérez

pmaciPa@drtico.uab.eslemas de la concurrencia
WAIT

01 Semáforos

Si el valor del semáforo es mayor que 0, 
decrementa el contador y permite que el 
proceso entre en la sección crítica.

Si el valor es 0, el proceso se bloquea y 
espera hasta que otro proceso incremente el 
semáforo.



Francisco Maciá Pérez

pmaciaM@dtice.ua.cesanismos de Sincronización
Operaciones en los semáforos

01 Semáforos

2. signal() (también conocida como V o up, release() en Python):

Concurrencia



Francisco Maciá Pérez

pmaciPa@drtico.uab.eslemas de la concurrencia
SIGNAL

01 Semáforos

Incrementa el valor del semáforo y despierta a 
cualquier proceso que esté esperando para 
entrar en la sección crítica



Francisco Maciá Pérez

pmaciaM@dtice.ua.cesanismos de Sincronización
Ejemplo

01 Semáforos

Problema del Productor-Consumidor tamaño ilimitado

o Dos procesos (un productor y un consumidor) que comparten un buffer 
de tamaño ilimitado.

P C

Concurrencia



Francisco Maciá Pérez

pmaciaM@dtice.ua.cesanismos de Sincronización
Ejemplo

01 Semáforos

Problema del Productor-Consumidor

o Dos procesos (un productor y un consumidor) que comparten un buffer 
de tamaño fijo.

o El productor añade elementos al buffer y el consumidor los consume

P C

Concurrencia



Francisco Maciá Pérez

pmaciaM@dtice.ua.cesanismos de Sincronización
Ejemplo

01 Semáforos

Problema del Productor-Consumidor

o Dos procesos (un productor y un consumidor) que comparten un buffer 
de tamaño fijo.

o El productor añade elementos al buffer y el consumidor los consume

P C

Concurrencia



Francisco Maciá Pérez

pmaciaM@dtice.ua.cesanismos de Sincronización
Ejemplo

01 Semáforos

Problema del Productor-Consumidor

o Dos procesos (un productor y un consumidor) que comparten un buffer 
de tamaño fijo.

o El productor añade elementos al buffer y el consumidor los consume

P C

Concurrencia



Francisco Maciá Pérez

pmaciPa@drtico.uab.eslemas de la concurrencia
Productor-Consumidor buffer ilimitado

01 Semáforos

void productor() { Lanzar los procesos en paralelo
void consumidor() {

while (true) { while (true) { Solo uno de los dos procesos puede tener 
producir();

acceso al buffer, de modo que hay que 
identificar la sección crítica (exclusión mutua)

añadir_buffer(); coger_ buffer();

consumir();
} }

} }

void main() {

cobegin
productor();
consumidor();

coend;
}



Francisco Maciá Pérez

pmaciPa@drtico.uab.eslemas de la concurrencia
Productor-Consumidor buffer ilimitado

01 Semáforos

void productor() { Lanzar los procesos en paralelo
void consumidor() {

while (true) { while (true) { Solo uno de los dos procesos puede tener 
producir();

acceso al buffer, de modo que hay que 
identificar la sección crítica (exclusión mutua)

añadir_buffer(); coger_ buffer();

consumir();
} }

} }

void main() {

cobegin
productor();
consumidor();

coend;
}



Francisco Maciá Pérez

pmaciPa@drtico.uab.eslemas de la concurrencia
Productor-Consumidor buffer ilimitado

01 Semáforos

TSemáforo s , n;

void productor() { Lanzar los procesos en paralelo
void consumidor() {

while (true) { while (true) { Solo uno de los dos procesos puede tener 
producir(); wait(n);      acceso al buffer, de modo que hay que 
wait(s); wait(s); identificar la sección crítica (exclusión mutua)
añadir_buffer(); coger_ buffer();
signal(s); Creamos un semáforo s para la sección 

signal(s);
signal(n); crítica y lo inicializamos en 1, así el primer 

consumir();
} proceso que acceda podrá entrar.

}
} } El consumidor solo puede consumir si hay 

algo en el buffer (sincronización de procesos)

Creamos un semáforo n para la sincronización 
y lo inicializamos en 0, así si el consumidor 

void main() { llega antes tiene que esperar

inicializar(s, 1);    WAIT:

inicializar(n, 0); • Si el valor del semáforo es mayor que 0, 
decrementa el contador y permite que el 

cobegin
proceso entre en la sección crítica. SIGNAL:

productor(); • Si el valor es 0, el proceso se bloquea y • Incrementa el valor del semáforo y 
consumidor(); espera hasta que otro proceso incremente despierta a cualquier proceso que esté 

coend; el semáforo. esperando para entrar en la sección crítica

}



Francisco Maciá Pérez

pmaciPa@drtico.uab.eslemas de la concurrencia
Productor-Consumidor 

01 Semáforos
Buffer Limitado

Lanzar los procesos en paralelo
TSemáforo s , n;, b;
#define tamaño_buffer N Solo uno de los dos procesos puede tener 

acceso al buffer, de modo que hay que 
identificar la sección crítica (exclusión mutua)

void productor() { void consumidor() {
while (true) { Creamos un semáforo s para la sección 

while (true) {
producir(); crítica y lo inicializamos en 1, así el primer 

wait(n);      
wait(b); proceso que acceda podrá entrar.

wait(s);
wait(s); coger_ buffer(); El consumidor solo puede consumir si hay 
añadir_buffer(); signal(s); algo en el buffer (sincronización de procesos)
signal(s); signal(b);
signal(n); Creamos un semáforo n para la sincronización 

consumir();
} y lo inicializamos en 0, así si el consumidor 

}
} llega antes tiene que esperar

}
Añadir un semáforo para que el productor no 
produzca si está lleno el buffer(sincronización 
de procesos)

void main() {
WAIT:

inicializar(s, 1);    • Si el valor del semáforo es mayor que 
inicializar(n, 0); 0, decrementa el contador y permite SIGNAL:

que el proceso entre en la sección • Incrementa el valor del 
inicializar(b, tamaño_buffer);

crítica. semáforo y despierta a 
cobegin

productor(); • Si el valor es 0, el proceso se bloquea cualquier proceso que esté 

y espera hasta que otro proceso esperando para entrar en la 
consumidor();

incremente el semáforo. sección crítica
coend;

}



Francisco Maciá Pérez

pmaciPa@drtico.uab.eslemas de la concurrencia
Contador en Python

01 Semáforos



Francisco Maciá Pérez

pmaciPa@drtico.uab.eslemas de la concurrencia
Contador en Python

01 Semáforos

Cuando se usa with semaforo::

Adquisición: Al entrar en el bloque 
with, el semáforo se adquiere 
automáticamente. Esto significa que el 
hilo que entra en este bloque puede 
proceder a ejecutar el código dentro de 
él si el semáforo está disponible. 

Liberación: Al salir del bloque with
(ya sea porque el código se ejecutó 
con éxito o porque ocurrió una 
excepción), el semáforo se libera 
automáticamente. Esto asegura que 
otros hilos puedan adquirirlo.



Francisco Maciá Pérez

pmaciaM@dtice.ua.cesanismos de Sincronización
Contenido

Semáforos 01

Mutex 02

Monitores 03

Concurrencia



Francisco Maciá Pérez

pmaciaM@dtice.ua.cesanismos de Sincronización
Mutex

02 Mutex

Un mutex es un objeto de sincronización que se utiliza para 
garantizar que solo un hilo tenga acceso a un recurso compartido a la 
vez. 

Características de un Mutex:
• Exclusividad: Solo un hilo puede poseer un mutex a la vez. Si un 

hilo ha adquirido el mutex, otros hilos que intenten adquirirlo se 
bloquearán hasta que el mutex sea liberado.

• Sección Crítica: Se utiliza para proteger secciones críticas en el 
código donde se accede a recursos compartidos

Un semáforo, a diferencia de un mutex, puede permitir que varios 
hilos accedan a un recurso compartido simultáneamente

Concurrencia



Francisco Maciá Pérez

pmaciPa@drtico.uab.eslemas de la concurrencia
Contadores

02 Mutex



Francisco Maciá Pérez

pmaciaM@dtice.ua.cesanismos de Sincronización
Contenido

Semáforos 01

Mutex 02

Monitores 03

Concurrencia



Francisco Maciá Pérez

pmaciaM@dtice.ua.cesanismos de Sincronización
Monitores

03 Monitores

Los monitores no son un tipo de sincronización a nivel de sistema 
operativo, sino que son una abstracción de alto nivel creada por los 
programadores o lenguajes de programación para facilitar la 
sincronización y la exclusión mutua. 
En esencia, los monitores encapsulan mecanismos más básicos de 
sincronización, como mutexes o semaforos, que sí son gestionados 
por el sistema operativo o el runtime de la aplicación.

Concurrencia



Francisco Maciá Pérez

pmaciaM@dtice.ua.cesanismos de Sincronización
Contenido

Semáforos 01

Mutex 02

Monitores 03

Concurrencia



Francisco Maciá Pérez

pmacia@dtic.ua.es

Señales IPC
Tuberías

Contenidos

Memoria compartida



Francisco Maciá Pérez

pmacia@dtic.ua.es

IPC
Inter Process Comunication

IPC (Inter-Process Communication) se refiere a los mecanismos y técnicas 
utilizados para que los procesos que se ejecutan en un sistema operativo 
puedan comunicarse y compartir datos entre sí. Los procesos son 
generalmente independientes y están aislados unos de otros, pero en 
muchas aplicaciones es crucial que estos procesos trabajen en conjunto y 
colaboren de manera coordinada

P1 P2

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

IPC
Inter Process Comunication

IPC (Inter-Process Communication) se refiere a los mecanismos y técnicas 
utilizados para que los procesos que se ejecutan en un sistema operativo 
puedan comunicarse y compartir datos entre sí. Los procesos son 
generalmente independientes y están aislados unos de otros, pero en 
muchas aplicaciones es crucial que estos procesos trabajen en conjunto y 
colaboren de manera coordinada

Memoria de usuarios Memoria del kernel

PROPC1ESO 1

PROCESO 2
P2

PCB (PROCESS CONTROL BLOCK)

TABLA DE 
PROCESOS

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

IPC
Inter Process Comunication

➢ Los sistemas operativos modernos suelen ejecutar cada proceso 
en su propio espacio de memoria aislado por razones de 
seguridad y estabilidad. 

➢ Este aislamiento evita que un proceso interfiera directamente 
con los datos de otro. 

➢ Sin embargo, en aplicaciones complejas, múltiples procesos 
deben colaborar para realizar tareas más grandes. 

➢ IPC proporciona un puente seguro entre estos espacios de 
memoria aislados para que los procesos puedan intercambiar 
información.

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Señales

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Señales
Definiciones

➢ Las señales (signals) son un mecanismo de comunicación asíncrona 
en sistemas operativos tipo Unix (como Linux), que permiten a los 
procesos notificarse sobre ciertos eventos. 

➢ Las señales pueden ser enviadas por el sistema operativo, por otros 
procesos o incluso por el mismo proceso para notificar la ocurrencia 
de eventos como interrupciones, errores, finalización de procesos, 
etc.

➢ Cuando un proceso recibe una señal, puede reaccionar a ella de 
diferentes maneras, como ejecutar una función específica (llamada 
manejador de señales) o simplemente ignorar la señal.

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Señales
Cómo funcionan

¿Cómo funcionan las señales? 

Envío de señales: 
Las señales pueden ser enviadas a un proceso para indicarle que algo 
sucedió. Por ejemplo, la señal SIGINT (señal de interrupción) se envía 
cuando el usuario presiona Ctrl + C en la terminal. 

Manejadores de señales: 
Un proceso puede definir una función especial llamada manejador de 
señales (signal handler) que se ejecuta cuando el proceso recibe una señal 
específica. 
Si no se define un manejador, el proceso puede usar la acción por defecto 
para esa señal, que en algunos casos podría ser terminar el proceso.

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Señales
Ejemplo de señales

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Señales
Funciones en C

signal(int sig, void (*handler)(int))

Se utiliza para registrar un manejador de señales. Permite que el proceso 
asocie una función a una señal específica.

kill(pid_t pid, int sig)

Se utiliza para enviar una señal a un proceso.

int alarm(int seconds)

Configura una alarma para que se envíe la señal SIGALRM al proceso 
después de un tiempo específico (en segundos).

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es Señales
Ejemplo de código



Francisco Maciá Pérez

pmacia@dtic.ua.es Señales
Ejemplo de código



Francisco Maciá Pérez

pmacia@dtic.ua.es

Tuberías

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Tuberías
Definiciones

➢ Las tuberías o pipes son un mecanismo de comunicación entre 
procesos (IPC) que permite que dos procesos se comuniquen entre 
sí de manera eficiente, utilizando un canal unidireccional. 

➢ Las tuberías permiten enviar datos de un proceso a otro, 
funcionando de manera similar a cómo funciona una tubería física: 
los datos entran por un extremo y salen por el otro.

P1 P2

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Tuberías
Definiciones

Características principales:
•Unidireccionales: Las tuberías permiten que los datos fluyan en una 
sola dirección (de un proceso escritor a un proceso lector). Si se 
necesita comunicación bidireccional, deben crearse dos tuberías.
•Anónimas o con nombre:

• Tuberías anónimas: Se utilizan principalmente entre procesos 
relacionados (por ejemplo, procesos padre-hijo). Son 
temporales y no tienen un nombre en el sistema de archivos.

• Tuberías con nombre (named pipes o FIFOs): Son 
identificadas por un nombre en el sistema de archivos y pueden 
ser usadas por procesos no relacionados.

•Bloqueo: Cuando un proceso escribe en la tubería, si no hay otro 
proceso leyendo, el proceso escritor puede quedar bloqueado hasta que 
los datos sean leídos (y viceversa).

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Tuberías
Definiciones

Ejemplo de uso de una tubería en Linux:

Una tubería permite conectar la salida estándar (stdout) de un 
comando con la entrada estándar (stdin) de otro comando. Esto se 
puede hacer fácilmente en la terminal usando el carácter |

ls -l | grep ".txt"

1. El comando ls -l genera una lista de archivos, y su salida es enviada 
a una tubería.

2. El comando grep ".txt" recibe la salida a través de la tubería y filtra 
los archivos que terminan en .txt

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Tuberías
Memoria

• Para la gestión de las tuberías, el SO utiliza la abstracción de 
archivos.

• De esta forma, cuando se crea una tubería se crean dos descriptores 
de archivo (uno de lectura y otro de escritura).

Memoria de usuarios Memoria del kernel

TABLA DESCRIPTORES
ARCHIVO TABLA DE ARCHIVOS ABIERTOS

fd read PROCESO 1
Tubería

fd write

Buffer
PROCESO 2

PCB (PROCESS CONTROL BLOCK)

TABLA DE 
PROCESOS

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Tuberías
Operaciones

Operación Descripción Ejemplo de Uso

pipe(fd) 
Crea una nueva tubería, que permite 

Crear tubería donde fd[0] es lectura y 
la comunicación entre procesos.

fd[1] es escritura.

Escribir en Envía datos a la tubería a través del 
write(fd[1], buffer, size)

tubería descriptor de escritura.

Lee datos de la tubería a través del 
Leer de tubería read(fd[0], buffer, size)

descriptor de lectura.

Cierra el extremo de lectura o 
Cerrar descriptor close(fd[0]) o close(fd[1])

escritura de la tubería.

IPC



Francisco Maciá Pérez
int main() {

pmacia@dtic.ua.es
int fd[2]; // Descriptores de la tubería: fd[0] para lectura, fd[1] para escritura
pid_t pid;
char buffer[100]; // Buffer para almacenar el mensaje
// Crear la tubería
if (pipe(fd) == -1) {

perror("pipe");
exit(EXIT_FAILURE);

}
// Crear un proceso hijo
pid = fork();
if (pid < 0) {

perror("fork");
exit(EXIT_FAILURE);

}
if (pid == 0) { // Proceso hijo

close(fd[1]); // Cerrar el extremo de escritura

// Leer el mensaje del padre
read(fd[0], buffer, sizeof(buffer));
printf("Mensaje recibido en el hijo: %s\n", buffer);

close(fd[0]); // Cerrar el extremo de lectura
exit(EXIT_SUCCESS);

} else { // Proceso padre
close(fd[0]); // Cerrar el extremo de lectura

const char *mensaje = "Hola desde el proceso padre!";

// Escribir el mensaje en la tubería
write(fd[1], mensaje, strlen(mensaje) + 1); // +1 para incluir el carácter nulo

close(fd[1]); // Cerrar el extremo de escritura
wait(NULL); // Esperar a que el hijo termine

}

exit(EXIT_SUCCESS);
}

Tuberías
Código de ejemplo



Francisco Maciá Pérez

pmacia@dtic.ua.es

Memoria compartida

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Memoria compartida
Definiciones

➢ La memoria compartida es un mecanismo de comunicación entre 
procesos que permite que varios procesos accedan a una misma 
región de memoria.

➢ Este método se utiliza para intercambiar datos de manera eficiente 
entre procesos que se están ejecutando en el mismo sistema 
operativo. 

➢ La memoria compartida es particularmente útil cuando se requiere 
un alto rendimiento y baja latencia en la comunicación entre 
procesos.

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Memoria Compartida
Operaciones

shmid=shmget(IPC_PRIVATE,sizeof(int),IPC_CREAT|0666)

numero=(int *) shmat (shmid,0,0); Adjunta la MC al proceso

shmdt(numero) Desadjunta la memoria del proceso

Memoria de usuarios Memoria del kernel

PROCESO 1 MEMORIA COMPARTIDA
shmid

numero* shmid

PROCESO 2

PCB (PROCESS CONTROL BLOCK)

TABLA DE 
PROCESOS

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Memoria Compartida
Operaciones

shmid=shmget(IPC_PRIVATE,sizeof(int),IPC_CREAT|0666)

numero=(int *) shmat (shmid,0,0); Adjunta la MC al proceso

shmdt(numero) Desadjunta la memoria del proceso

shmctl(shmid,IPC_RMID,0) Marca la MC para ser borrada cuando 
no haya procesos que la tengan adjunta.

Memoria de usuarios Memoria del kernel

PROCESO 1 MEMORIA COMPARTIDA
shmid

PROCESO 2

PCB (PROCESS CONTROL BLOCK)

TABLA DE 
PROCESOS

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Memoria Compartida
Operaciones

shmid=shmget(IPC_PRIVATE,sizeof(int),IPC_CREAT|0666)

numero=(int *) shmat (shmid,0,0); Adjunta la MC al proceso

shmdt(numero) Desadjunta la memoria del proceso

shmctl(shmid,IPC_RMID,0) Marca la MC para ser borrada cuando 
no haya procesos que la tengan adjunta.

Memoria de usuarios Memoria del kernel

PROCESO 1 MEMORIA COMPARTIDA
shmid

numero* PROCESO 2
shmid

PCB (PROCESS CONTROL BLOCK)

shmdt(numero)
TABLA DE 
PROCESOS

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Memoria Compartida
Operaciones

shmid=shmget(IPC_PRIVATE,sizeof(int),IPC_CREAT|0666)

numero=(int *) shmat (shmid,0,0); Adjunta la MC al proceso

shmdt(numero) Desadjunta la memoria del proceso

shmctl(shmid,IPC_RMID,0) Marca la MC para ser borrada cuando 
no haya procesos que la tengan adjunta.

Memoria de usuarios Memoria del kernel

PROCESO 1 MEMORIA COMPARTIDA
shmid

PROCESO 2

PCB (PROCESS CONTROL BLOCK)

TABLA DE 
PROCESOS

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es

Memoria Compartida
Operaciones

shmid=shmget(IPC_PRIVATE,sizeof(int),IPC_CREAT|0666)

numero=(int *) shmat (shmid,0,0); Adjunta la MC al proceso

shmdt(numero) Desadjunta la memoria del proceso

shmctl(shmid,IPC_RMID,0) Marca la MC para ser borrada cuando 
no haya procesos que la tengan adjunta.

Memoria de usuarios Memoria del kernel

PROCESO 1

PROCESO 2

PCB (PROCESS CONTROL BLOCK)

TABLA DE 
PROCESOS

IPC



Francisco Maciá Pérez

pmacia@dtic.ua.es
int main() {

int shmid = shmget(IPC_PRIVATE, sizeof(int), IPC_CREAT | 0666);

// Crear un proceso hijo
pid_t pid = fork();

if (pid == 0) { // Proceso hijo

int *data = (int *) shmat(shmid, NULL, 0);// Adjuntar el segmento de memoria compartida
if (data == (int *) -1) {

perror("Error al adjuntar el segmento en el hijo");
exit(1);

}

printf("Proceso hijo: El número en memoria compartida es: %d\n", *data);
if (shmdt(data) < 0) {

perror("Error al desadjuntar el segmento en el hijo");
exit(1);

}
} else {

// Proceso padre
int *data = (int *) shmat(shmid, NULL, 0);
*data = 42; // Almacena el número 42
if (shmdt(data) < 0) {

perror("Error al desadjuntar el segmento en el padre");
exit(1);

}
wait(NULL);
if (shmctl(shmid, IPC_RMID, NULL) < 0) {

perror("Error al eliminar el segmento");
exit(1);

} ¿Problema de 
} sincronización?
exit (0)

}

Memoria Compartida
Código de ejemplo sin control de errores exhaustivo



Francisco Maciá Pérez
int *data; // Puntero a la memoria compartida

pmacia@dtic.ua.es

void manejador(int signum) {
printf("Proceso hijo: El número en memoria compartida es: %d\n", *data);
shmdt(data) //Falta controlar errores
exit(0);

}

int main() {
int shmid = shmget(IPC_PRIVATE, sizeof(int), IPC_CREAT | 0666);

pid_t pid = fork();

if (pid == 0) { // Proceso hijo

data = (int *) shmat(shmid, NULL, 0);
signal(SIGUSR1, manejador);
pause(); // El proceso hijo queda en pausa hasta recibir la señal

} else { // Proceso padre

data = (int *) shmat(shmid, NULL, 0);
*data = 42;
printf("Proceso padre: Número 42 escrito en memoria compartida\n");

kill(pid, SIGUSR1);

wait(NULL);

shmdt(data) //Falta controlar errores

if (shmctl(shmid, IPC_RMID, NULL) == -1) {
perror("Error al eliminar el segmento de memoria compartida");
exit(1);

}
printf("Proceso padre: Memoria compartida eliminada\n");

}
exit(0);

}

Memoria Compartida
Código de ejemplo sin control de errores exhaustivo



Tema 1.3 Sistema de Archivos,
Concurrencia e IPC

Contenidos

Sistema de archivos
Estructura, Interfaz

Concurrencia
Definición, problemas y sincronización

IPC
Señales, tuberías, memoria compartida y sockets



Sistemas Operativos y 
Distribuidos

Iren Lorenzo Fonseca
iren.fonseca@.ua.es

TEMA 1. Sistemas Operativos.

Sistema de Archivos, 
Concurrencia e IPC